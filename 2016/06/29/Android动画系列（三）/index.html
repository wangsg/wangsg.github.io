<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="xxx"><title>Android动画系列（三） | 彩色心情</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.1.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.3/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android动画系列（三）</h1><a id="logo" href="/.">彩色心情</a><p class="description">学而不思则罔,思而不学则殆</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android动画系列（三）</h1><div class="post-meta">Jun 29, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/06/29/Android动画系列（三）/" href="/2016/06/29/Android动画系列（三）/#comments" class="ds-thread-count"></a><div class="post-content"><h2 id="Property_Animation__u7684_u5DE5_u4F5C_u65B9_u5F0F"><a href="#Property_Animation__u7684_u5DE5_u4F5C_u65B9_u5F0F" class="headerlink" title="Property Animation 的工作方式"></a>Property Animation 的工作方式</h2><p>Property Animation 动画有两个步聚：</p>
<ol>
<li>计算属性值</li>
<li>为目标对象的属性设置属性值，即应用和刷新动画<h3 id="u8BA1_u7B97_u5C5E_u6027_u503C"><a href="#u8BA1_u7B97_u5C5E_u6027_u503C" class="headerlink" title="计算属性值"></a>计算属性值</h3>过程一：计算已完成动画分数 elapsed fraction 为了执行一个动画，你需要创建一个 ValueAnimator，并且指定目标对象属性的开始、结束值和持续时间。在调用 start 后的整个动画过程中， ValueAnimator 会根据已经完成的动画时间计算得到一个 0 到 1 之间的分数，代表该动画的已完成动画百分比。0 表示 0%，1 表示 100%。<br>此文章截取转摘于<a href="http://a.codekk.com/detail/Android/lightSky/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Android%20%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80" target="_blank" rel="external">公共技术点之 Android 动画基础</a><br>过程二：计算插值（动画变化率）interpolated fraction 当 ValueAnimator 计算完已完成动画分数后，它会调用当前设置的 TimeInterpolator，去计算得到一个 interpolated（插值）分数，在计算过程中，已完成动画百分比会被加入到新的插值计算中。<br>过程三：计算属性值 当插值分数计算完成后，ValueAnimator 会根据插值分数调用合适的 TypeEvaluator 去计算运动中的属性值。<br>以上分析引入了两个概念：已完成动画分数（elapsed fraction）、插值分数( interpolated fraction )。<h3 id="u6838_u5FC3_u7C7B"><a href="#u6838_u5FC3_u7C7B" class="headerlink" title="核心类"></a>核心类</h3>属性动画类继承关系</li>
</ol>
<ul>
<li>Interpolators<br>插值器：时间的函数，定义了动画的变化律。<br>插值器只需实现一个方法：getInterpolation(float input),其作用就是把 0 到 1 的 elapsed fraction 变化映射到另一个 interpolated fraction。 Interpolator 接口的直接继承自TimeInterpolator，内部没有任何方法，而TimeInterpolator只有一个getInterpolation方法，所以所有的插值器只需实现getInterpolation方法即可。<br>传入参数是正常执行动画的时间点，返回值是调用者真正想要它执行的时间点。传入参数是{0,1}，返回值一般也是{0,1}。{0,1}表示整段动画的过程。中间的 0.2、0.3 等小数表示在整个动画（原本是匀速的）中的位置，其实就是一个比值。如果返回值是负数，会沿着相反的方向执行。如果返回的是大于 1，会超出正方向执行。也就是说，动画可能在你指定的值上下波动，大多数情况下是在指定值的范围内。<br>getInterpolation(float input)改变了默认动画的时间点 elapsed fraction，根据时间点 interpolated fraction 得到的是与默认时间点不同的属性值，插值器的原理就是通过改变实际执行动画的时间点，提前或延迟默认动画的时间点来达到加速/减速的效果。动画插值器目前都只是对动画执行过程的时间进行修饰，并没有对轨迹进行修饰。<br>简单点解释这个方法，就是当要执行 input 的时间时，通过 Interpolator 计算返回另外一个时间点，让系统执行另外一个时间的动画效果。</li>
<li>Evaluators</li>
</ul>
<p>Evaluators 告诉属性动画系统如何去计算一个属性值。它们通过 Animator 提供的动画的起始和结束值去计算一个动画的属性值。 属性系统提供了以下几种 Evaluators：<br>1.IntEvaluator<br>2.FloatEvaluator<br>3.ArgbEvaluator<br>这三个由系统提供，分别用于计算 int，float，color 型（十六进制）属性的计算器<br>4.TypeEvaluator<br>一个用于用户自定义计算器的接口，如果你的对象属性值类型，不是 int，float，或者 color 类型，你必须实现这个接口，去定义自己的数据类型。<br>TypeEvaluator接口只有一个方法，就是evaluate()方法，它允许你使用的 animator 返回一个当前动画点的属性值。<br>TimeInterpolator 和 TypeEvaluator 的区别<br>首先明确动画属性值的计算包括三步，其中第二步和第三步分别需要借助TimeInterpolator和TypeEvluator完成。<br>TypeEvaluator所做的是根据数据结构计算最终的属性值，允许你定义自己的数据结构，这是官方对它的真正定义，如果你所定义的属性值的数据类型不是 float、int、color 类型，那么你需要实现 TypeEvaluator 接口的evaluate()方法，自己进行属性值的计算<br>Interpolator更倾向于你定义一种运动的变化率，比如匀速、加速、减速等，官方对 Interpolator 的定义也确实是这样的：<br>A time interpolator defines the rate of change of an &gt;animation. This allows animations to have non-linear &gt;motion, such as acceleration and deceleration.<br>对于自定义高级动画时，弄清TimeInterpolator和TypeEvaluator非常重要，如果你希望要自定义自己的动画，那么这两个函数肯定是关键部分，一个是定义动画变化率，一个是定义数据结构和属性值计算方式，两者共同决定了一个动画的运动。</p>
<ul>
<li>ValueAnimator</li>
</ul>
<p>属性动画中的主要的时序引擎，如动画时间，开始、结束属性值，相应时间属性值计算方法等。包含了所有计算动画值的核心函数。也包含了每一个动画时间上的细节，信息，一个动画是否重复，是否监听更新事件等，并且还可以设置自定义的计算类型。<br>使用 ValueAnimator 实现动画需要手动更新：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ValueAnimator animation = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">animation.setDuration(<span class="number">1000</span>);</span><br><span class="line">animation.addUpdateListener(<span class="keyword">new</span> AnimatorUpdateListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"update"</span>, ((Float) animation.getAnimatedValue()).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">animation.setInterpolator(<span class="keyword">new</span> CycleInterpolator(<span class="number">3</span>));</span><br><span class="line">animation.start();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>ObjectAnimator<br>继承自ValueAnimator，允许你指定要进行动画的对象以及该对象的一个属性。该类会根据计算得到的新值自动更新属性。也就是说上 Property Animation 的两个步骤都实现了。大多数的情况，你使用ObjectAnimator就足够了，因为它使得目标对象动画值的处理过程变得简单，不用再向ValueAnimator那样自己写动画更新的逻辑。但ObjectAnimator有一定的限制，比如它需要目标对象的属性提供指定的处理方法，这个时候你需要根据自己的需求在ObjectAnimator和ValueAnimator中做个选择了，看哪种实现更简便。<br>ObjectAnimator的自动更新功能，依赖于属性身上的setter和getter方法，所以为了让ObjectAnimator能够正确的更新属性值，你必须遵从以下规范:<br>该对象的属性必须有get和set方法（方法的格式必须是驼峰式），方法格式为 set()，因为 ObjectAnimator 会自动更新属性，它必须能够访问到属性的setter方法，比如属性名为foo,你就需要一个setFoo()方法，如果 setter 方法不存在，你有三种选择：<br>a.添加 setter 方法<br>b.使用包装类。通过该包装类通过一个有效的 setter 方法获取或者改变属性值的方法，然后应用于原始对象，比如 NOA 的AnimatorProxy。<br>c.使用 ValueAnimator 代替<br>（这 3 点的意思总结起来就是一定要有一个setter方法，让ObjectAnimator能够访问到）<br>如果你为 ObjectAnimator 的工厂方法的可变参数只传递了一个值，那么会被作为动画的结束值。<br>注意，属性的getter方法和setter方法必须必须是相对应的，比如你构造了一个如下的ObjectAnimator，那么getter和setter方法就应该为：<br>targetObject.setPropName(float) 和 targetObject.getPropName(float) :<br>ObjectAnimator.ofFloat(targetObject, “propName”, 1f)<br>根据动画的目标属性或者对象不同，你可能需要调用某一个 View 的invalidate方法，根据新的动画值去强制屏幕重绘该 View。可以在onAnimateonUpdate()回调方法中去做。比如，对一个 Drawable 的颜色属性进行动画，只有当对象重绘自身的时候，才会导致该属性的更新，（不像平移或者缩放那样是实时的）。一个 View 的所有 setter 属性方法，比如setAlpha()和setTranslationX()都可以适当的更新 View。因此你不需要在重绘的时候为这些方法传递新的值。更多关于 Listener 的信息，可以参考第四部分 Animation Listeners。<br>简单总结下： 当你不希望向外暴露Setter方法的时候，或者希望获取到动画值统一做处理的话，亦或只需要一个简单的时序机制(拥有动画的各种值)的话，那么你可以选择使用ValueAnimator，它更简单。如果你就是希望更新动画，为了简便，可以使用ObjectAnimator，但自定义的属性必须有setter和getter方法，并且它们必须都是标准的驼峰式（确保内部能够调用），必须有结束值。你可以实现Animator.AnimatorListener接口根据自己的需求去更新 View。</li>
<li>AnimatorSet</li>
</ul>
<p>提供组合动画能力的类。并可设置组中动画的时序关系，如同时播放、有序播放或延迟播放。Elevator会告诉属性动画系统如何计算一个属性的值，它们会从Animator类中获取时序数据，比如开始和结束值，并依据这些数据计算动画的属性值。<br>小结： TypeEvaluator<br>定义了属性值的计算方式，有 int,float,color 类型，根据属性的开始、结束值和插值一起计算出当前时间的属性值，终极方法，整个动画属性值计算过程的结尾。<br>TimeInterpolation<br>插值器都必须实现的接口，定义了动画的变化率，如线性，非线性。<br>ValueAnimator与ObjectAnimator：<br>两者都可以进行属性动画，但是ObjectAnimator更加简单，不用去做更新属性值的计算，但是必须要提供标准的setter和getter方法，让ObjectAnimator能够获取和更新属性值。</p>
<ul>
<li>ViewPropertyAnimator</li>
</ul>
<p>可以方便的为某个 View 的多个属性添加并行的动画，只使用一个ViewPropertyAnimator对象就可以完成。它的行为更像一个ObjectAnimator，因为它修改的是对象的实际属性值。但它为一次性给多个属性添加动画提供了方便，而且使用ViewPropertyAnimator的代码更连贯更易读。<br>下面的代码段分别展示了使用多个ObjectAnimator对象、一个ObjectAnimator对象、 ViewPropertyAnimator同时为一个 View 的 X 和 Y 属性添加动画的示例：<br>多个 ObjectAnimator 结合 AnimatorSet 实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator animX = ObjectAnimator.ofFloat(myView, <span class="string">"x"</span>, <span class="number">50f</span>);</span><br><span class="line">ObjectAnimator animY = ObjectAnimator.ofFloat(myView, <span class="string">"y"</span>, <span class="number">100f</span>);</span><br><span class="line">AnimatorSet animSetXY = <span class="keyword">new</span> AnimatorSet();</span><br><span class="line">animSetXY.playTogether(animX, animY);</span><br><span class="line">animSetXY.start();</span><br><span class="line">一个 ObjectAnimator 结合多个 PropertyValuesHolder 实现</span><br><span class="line">PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(<span class="string">"x"</span>, <span class="number">50f</span>);</span><br><span class="line">PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(<span class="string">"y"</span>, <span class="number">100f</span>);</span><br><span class="line">ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();</span><br><span class="line">ViewPropertyAnimator: 只需一行代码</span><br><span class="line">myView.animate().x(<span class="number">50f</span>).y(<span class="number">100f</span>);<span class="comment">//myView.animate()直接返回一个 ViewPropertyAnimator 对象</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>PropertyValuesHolder<br>顾名思义，该类持有属性，相关属性值的操作以及属性的 setter，getter 方法的创建，属性值以 Keyframe 来承载，最终由 KeyframeSet 统一处理。</li>
<li>KeyFrame</li>
</ul>
<p>一个keyframe对象由一对 time / value 的键值对组成，可以为动画定义某一特定时间的特定状态。<br>每个keyframe可以拥有自己的插值器，用于控制前一帧和当前帧的时间间隔间内的动画。<br>Keyframe.ofFloat(0f,0f); 第一个参数为：要执行该帧动画的时间节点（elapsed time / duration）<br>第二个参数为属性值。<br>因此如果你想指定某一特定时间的特定状态，那么简单的使用 ObjectAnimator就满足不了你了，因为，ObjectAnimator.ofInt(….)类似的工厂方法，无法指定特定的时间点的状态。<br>每个 KeyFrame 的 Interpolator<br>每个KeyFrame其实也有个Interpolator。如果没有设置，默认是线性的。之前为Animator设置的Interpolator是整个动画的，而系统允许你为每一KeyFrame的单独定义Interpolator，系统这样做的目的是允许你在某一个keyFrame做特殊的处理，也就是整体上是按照你的插值函数来计算，但是，如果你希望某个或某些KeyFrame会有不同的动画表现，那么你可以为这个keyFrame设置Interpolator。<br>因此，Keyframe 的定制性更高，你如果想精确控制某一个时间点的动画值及其运动规律，你可以自己创建特定的 Keyframe<br>Keyframe 使用<br>为了实例化一个keyframe对象，你必须使用某一个工厂方法：ofInt(), ofFloat(), or ofObject() 去获取合适的keyframe类型，然后你调用ofKeyframe工厂方法去获取一个PropertyValuesHolder对象，一旦你拥有了该对象，你可以将 PropertyValuesHolder 作为参数获取一个Animator，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Keyframe kf0 = Keyframe.ofFloat(<span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line">Keyframe kf1 = Keyframe.ofFloat(.<span class="number">5f</span>, <span class="number">360f</span>);</span><br><span class="line">Keyframe kf2 = Keyframe.ofFloat(<span class="number">1f</span>, <span class="number">0f</span>);</span><br><span class="line">PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(<span class="string">"rotation"</span>, kf0, kf1, kf2);<span class="comment">//动画属性名，可变参数</span></span><br><span class="line">ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation)</span><br><span class="line">rotationAnim.setDuration(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>KeyFrameSet<br>根据 Animator 传入的值，为当前动画创建一个特定类型的 KeyFrame 集合。<br>通常通过 ObjectAnimator.ofFloat(…)进行赋值时，这些值其实是通过一个 KeyFrameSet 来维护的<br>比如：<br>ObjectAnimator.ofFloat(target, “translateX”, 50, 100, 200);<br>调用者传入的 values 为 50,100,200，则 numKeyframs = 3，那么创建出相应的 Keyframe 为： Keyframe(0,50)，Keyframe(1/2,100)，Keyframe(1,200), 时间点 0，1/2，1 都是按比例划分的<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyframeSet <span class="title">ofFloat</span><span class="params">(<span class="keyword">float</span>... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numKeyframes = values.length;</span><br><span class="line">        FloatKeyframe keyframes[] = <span class="keyword">new</span> FloatKeyframe[Math.max(numKeyframes,<span class="number">2</span>)];</span><br><span class="line">        <span class="keyword">if</span> (numKeyframes == <span class="number">1</span>) &#123;</span><br><span class="line">            keyframes[<span class="number">0</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="number">0f</span>);</span><br><span class="line">            keyframes[<span class="number">1</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="number">1f</span>, values[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            keyframes[<span class="number">0</span>] = (FloatKeyframe) Keyframe.ofFloat(<span class="number">0f</span>, values[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numKeyframes; ++i) &#123;</span><br><span class="line">                keyframes[i] = (FloatKeyframe) Keyframe.ofFloat((<span class="keyword">float</span>) i / (numKeyframes - <span class="number">1</span>), values[i]);<span class="comment">//这里是关键</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FloatKeyframeSet(keyframes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="u5728_XML__u4E2D_u58F0_u660E_u5C5E_u6027_u52A8_u753B"><a href="#u5728_XML__u4E2D_u58F0_u660E_u5C5E_u6027_u52A8_u753B" class="headerlink" title="在 XML 中声明属性动画"></a>在 XML 中声明属性动画</h3><p>通过在 XML 中定义的动画，可以很方便的在多个 Activities 中重用而且更容易编辑，复用性强。为了区分新的属性动画，从 3.1 开始，你应res/animator/下存放属性动画的资源文件，使用animator文件夹是可选的，但是如果你想在 Eclipse ADT 插件中使用布局编辑工具（ADT 11.0.0+），就必须在res/animator文件夹下存放了，因为 ADT 只会查找res/animator文件夹下的属性动画资源文件。<br>属性动画支持的 Tag 有<br>ValueAnimator - <animator><br>ObjectAnimator - <objectanimator><br>AnimatorSet - <set><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">set</span> <span class="attribute">android:ordering</span>=<span class="value">"sequentially"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">objectAnimator</span></span><br><span class="line">            <span class="attribute">android:propertyName</span>=<span class="value">"x"</span></span><br><span class="line">            <span class="attribute">android:duration</span>=<span class="value">"500"</span></span><br><span class="line">            <span class="attribute">android:valueTo</span>=<span class="value">"400"</span></span><br><span class="line">            <span class="attribute">android:valueType</span>=<span class="value">"intType"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">objectAnimator</span></span><br><span class="line">            <span class="attribute">android:propertyName</span>=<span class="value">"y"</span></span><br><span class="line">            <span class="attribute">android:duration</span>=<span class="value">"500"</span></span><br><span class="line">            <span class="attribute">android:valueTo</span>=<span class="value">"300"</span></span><br><span class="line">            <span class="attribute">android:valueType</span>=<span class="value">"intType"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">objectAnimator</span></span><br><span class="line">        <span class="attribute">android:propertyName</span>=<span class="value">"alpha"</span></span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"500"</span></span><br><span class="line">        <span class="attribute">android:valueTo</span>=<span class="value">"1f"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure></set></objectanimator></animator></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,</span><br><span class="line">    R.anim.property_animator);</span><br><span class="line">set.setTarget(myObject);</span><br><span class="line">set.start();</span><br></pre></td></tr></table></figure>
<p>目录 res/animator/filename.xm<br>编译后的资源为<br>ValueAnimator, ObjectAnimator, or AnimatorSet　<br>XML 文件的根元素必须为<set>,<objectanimator>, or <valueanimator>之一。也可以在一个 set 中组织不同的动画，包含其它<set>元素,也就是说，可以嵌套。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">set</span>  </span><br><span class="line">  <span class="attribute">android:ordering</span>=<span class="value">["together"</span> | "<span class="attribute">sequentially</span>"]&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">objectAnimator</span>  </span><br><span class="line">        <span class="attribute">android:propertyName</span>=<span class="value">"string"</span>  </span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"int"</span>  </span><br><span class="line">        <span class="attribute">android:valueFrom</span>=<span class="value">"float | int | color"</span>  </span><br><span class="line">        <span class="attribute">android:valueTo</span>=<span class="value">"float | int | color"</span>  </span><br><span class="line">        <span class="attribute">android:startOffset</span>=<span class="value">"int"</span>  </span><br><span class="line">        <span class="attribute">android:repeatCount</span>=<span class="value">"int"</span>  </span><br><span class="line">        <span class="attribute">android:repeatMode</span>=<span class="value">["repeat"</span> | "<span class="attribute">reverse</span>"]  </span><br><span class="line">        <span class="attribute">android:valueType</span>=<span class="value">["intType"</span> | "<span class="attribute">floatType</span>"]/&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">animator</span>  </span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"int"</span>  </span><br><span class="line">        <span class="attribute">android:valueFrom</span>=<span class="value">"float | int | color"</span>  </span><br><span class="line">        <span class="attribute">android:valueTo</span>=<span class="value">"float | int | color"</span>  </span><br><span class="line">        <span class="attribute">android:startOffset</span>=<span class="value">"int"</span>  </span><br><span class="line">        <span class="attribute">android:repeatCount</span>=<span class="value">"int"</span>  </span><br><span class="line">        <span class="attribute">android:repeatMode</span>=<span class="value">["repeat"</span> | "<span class="attribute">reverse</span>"]  </span><br><span class="line">        <span class="attribute">android:valueType</span>=<span class="value">["intType"</span> | "<span class="attribute">floatType</span>"]/&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">set</span>&gt;</span>  </span><br><span class="line">        ...  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">set</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure></set></valueanimator></objectanimator></set></p>
<h3 id="u5143_u7D20_u4ECB_u7ECD"><a href="#u5143_u7D20_u4ECB_u7ECD" class="headerlink" title="元素介绍"></a>元素介绍</h3><h4 id=""><a href="#" class="headerlink" title="<set>"></a><set></set></h4><p>动画集合节点，有一个属性 ordering，表示它的子动画启动方式是先后有序的还是同时。<br>属性<br>sequentially：动画按照先后顺序<br>together (default) ：动画同时启动</p>
<h4 id="-1"><a href="#-1" class="headerlink" title="<objectAnimator>"></a><objectanimator></objectanimator></h4><p>一个对象的一个属性，相应的 Java 类为:ObjectAnimator<br>属性<br>android:propertyName：<br>String 类型，必须要设定的值，代表要执行动画的属性，通过名字引用，比如你可以指定了一个 View 的”alpha” 或者 “backgroundColor”，这个 objectAnimator 元素没有暴露 target 属性，因此不能够在 XML 中执行一个动画，必须通过调用loadAnimator() 填充你的 XML 动画资源，并且调用setTarget() 应用到拥有这个属性的目标对象上。<br>android:valueTo<br>Float、int 或者 color，也是必须值，表明了动画结束的点，颜色由 6 位十六进制的数字表示。<br>android:valueFrom<br>相对应 valueTo，动画的起始点，如果没有指定，系统会通过属性身上的 get 方法获取，颜色也是 6 位十六进制的数字表示。<br>android:duration<br>动画的时长，int 类型，以毫秒为单位，默认为 300 毫秒。<br>android:startOffset<br>动画延迟的时间，从调用 start 方法后开始计算，int 型，毫秒为单位，<br>android:repeatCount<br>一个动画的重复次数，int 型，”-1“表示无限循环，”1“表示动画在第一次执行完成后重复执行一次，也就是两次，默认为 0，不重复执行。<br>android:repeatMode<br>重复模式：int 型，当一个动画执行完的时候应该如何处理。该值必须是正数或者是 -1，<br>“reverse”<br>会使得按照动画向相反的方向执行，可实现类似钟摆效果。<br>“repeat”<br>会使得动画每次都从头开始循环。<br>android:valueType<br>关键参数，如果该 value 是一个颜色，那么就不需要指定，因为动画框架会自动的处理颜色值。有 intType 和 floatType 两种：分别说明动画值为 int 和 float 型。</p>
<h4 id="-2"><a href="#-2" class="headerlink" title="<animator>"></a><animator></animator></h4><p>在一个特定的时间里执行一个动画。相对应的是 ValueAnimator.所有的属性和一样 android:valueTo<br>android:valueFrom<br>android:duration<br>android:startOffset<br>android:repeatCount<br>android:repeatMode<br>android:valueType<br>Value Description<br>floatType (default)<br>res/animator/property_animator.xml:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">set</span> <span class="attribute">android:ordering</span>=<span class="value">"sequentially"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">set</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">objectAnimator</span>  </span><br><span class="line">            <span class="attribute">android:propertyName</span>=<span class="value">"x"</span>  </span><br><span class="line">            <span class="attribute">android:duration</span>=<span class="value">"500"</span>  </span><br><span class="line">            <span class="attribute">android:valueTo</span>=<span class="value">"400"</span>  </span><br><span class="line">            <span class="attribute">android:valueType</span>=<span class="value">"intType"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">objectAnimator</span>  </span><br><span class="line">            <span class="attribute">android:propertyName</span>=<span class="value">"y"</span>  </span><br><span class="line">            <span class="attribute">android:duration</span>=<span class="value">"500"</span>  </span><br><span class="line">            <span class="attribute">android:valueTo</span>=<span class="value">"300"</span>  </span><br><span class="line">            <span class="attribute">android:valueType</span>=<span class="value">"intType"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">set</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">objectAnimator</span>  </span><br><span class="line">        <span class="attribute">android:propertyName</span>=<span class="value">"alpha"</span>  </span><br><span class="line">        <span class="attribute">android:duration</span>=<span class="value">"500"</span>  </span><br><span class="line">        <span class="attribute">android:valueTo</span>=<span class="value">"1f"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>为了执行该动画，必须在代码中将该动画资源文件填充为一个 AnimationSet 对象，然后在执行动画前，为目标对象设置所有的动画集合。<br>简便的方法就是通过 setTarget 方法为目标对象设置动画集合，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,  </span><br><span class="line">   R.anim.property_animator);  </span><br><span class="line">set.setTarget(myObject);  </span><br><span class="line">set.start();</span><br></pre></td></tr></table></figure></p>
<hr>
<p>借别人总结过的文章自己加以学习和汇总知识。其实也就是一些常用的api，后续准备和实际项目结合汇总。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/06/29/Android动画系列（三）/" data-id="ciqad63l30010r6fyzyrarrec" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Android动画深入分析/">Android动画深入分析</a></div><div class="post-nav"><a href="/2016/07/01/自定义View之基础/" class="pre">自定义View之基础</a><a href="/2016/06/29/Android动画系列（二）/" class="next">Android动画系列（二）</a></div><div data-thread-key="2016/06/29/Android动画系列（三）/" data-title="Android动画系列（三）" data-url="http://yoursite.com/2016/06/29/Android动画系列（三）/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/06/29/Android动画系列（三）/" data-title="Android动画系列（三）" data-url="http://yoursite.com/2016/06/29/Android动画系列（三）/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/Android自定义View基础/" style="font-size: 15px;">Android自定义View基础</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/技术杂谈/" style="font-size: 15px;">技术杂谈</a> <a href="/tags/Android-琐碎/" style="font-size: 15px;">Android 琐碎</a> <a href="/tags/Android设计模式/" style="font-size: 15px;">Android设计模式</a> <a href="/tags/Android动画深入分析/" style="font-size: 15px;">Android动画深入分析</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/自定义View之贝塞尔曲线/">自定义View之贝塞尔曲线</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/自定义View之Path基础/">自定义View之Path基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/自定义View之基础/">自定义View之基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/Android动画系列（三）/">Android动画系列（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/Android动画系列（二）/">Android动画系列（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/Android动画系列（一）/">Android动画系列（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/<转>程序员，你迷茫么？你忧伤么？/"><转>程序员，你迷茫么？你忧伤么？</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/17/关于Android中MVP/">关于Android中MVP</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/15/拾起以前学习的好习惯/">拾起以前学习的好习惯</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/03/2015年终总结/">2015年终总结</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.csdn.net/sinyu890807/article/list/5" title="郭霖大婶" target="_blank">郭霖大婶</a><ul></ul><a href="http://blog.csdn.net/singwhatiwanna" title="任大侠" target="_blank">任大侠</a><ul></ul><a href="http://gank.io/" title="干货集中营" target="_blank">干货集中营</a><ul></ul><a href="http://p.codekk.com/" title="codeKK" target="_blank">codeKK</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">彩色心情.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'wangsg'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5b8c220205c8c6f8ff1c458c7b53c17b";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>